const b="LibraryConfigDB",c="dirHandle",d="libraryFolder";let a=null,s=null,f=Promise.resolve();function w(){return new Promise((e,r)=>{const o=indexedDB.open(b,1);o.onupgradeneeded=t=>{const n=t.target.result;n.objectStoreNames.contains(c)||n.createObjectStore(c)},o.onsuccess=t=>e(t.target.result),o.onerror=t=>r(t.target.error)})}async function m(e){const o=(await w()).transaction(c,"readwrite");return o.objectStore(c).put(e,d),new Promise((n,i)=>{o.oncomplete=n,o.onerror=()=>i(o.error)})}async function h(){const t=(await w()).transaction(c,"readonly").objectStore(c).get(d);return new Promise((n,i)=>{t.onsuccess=()=>n(t.result),t.onerror=()=>i(t.error)})}async function S(){if(a)return!0;try{if(a=await h(),a)return await k(a,!1,!1)?!0:(console.log("Permission lost or need refresh"),!1)}catch(e){console.log("Init storage failed:",e)}return!1}function E(){return!!a}function H(){return a?a.name:null}async function B(){try{return a=await window.showDirectoryPicker({id:"ipusnas-library",mode:"readwrite"}),await m(a),!0}catch(e){if(e.name==="AbortError")return!1;throw console.log("Directory selection failed:",e),e}}async function k(e,r,o=!0){const t={};return!!(await e.queryPermission(t)==="granted"||o&&await e.requestPermission(t)==="granted")}async function g(e,r=!1){if(!a)throw new Error("Storage not configured");return await(await a.getDirectoryHandle("books",{create:!0})).getFileHandle(e,{create:r})}async function x(e,r,o){const t=await D(e,r,o);await p(e,{bookId:e,ext:o,...t})}async function P(e){if(!a)throw new Error("Storage not configured");const o=(await l()).find(n=>n.bookId===e);if(!o)throw new Error("Book not found in metadata");const t=`${e}.${o.ext||"pdf"}`;try{const i=await(await g(t)).getFile();return{...o,file:i}}catch(n){throw console.log("File missing for book:",e,n),n}}async function N(e){if(!a)throw new Error("Storage not configured");const o=(await l()).find(t=>t.bookId===e);if(o){try{const t=`${e}.${o.ext||"pdf"}`;await(await a.getDirectoryHandle("books")).removeEntry(t)}catch(t){console.log("File already gone or error deleting:",t)}await F(e)}}async function y(e=!1){if(!a)throw new Error("Storage not configured");return await a.getFileHandle("booklist.json",{create:e})}async function l(e=!1){if(!a)return[];if(s&&!e)return s;try{const t=await(await(await y(!1)).getFile()).text();s=JSON.parse(t)}catch(r){if(r.name==="NotFoundError")s=[];else throw console.log("Error reading booklist:",r),r}return s}async function u(e){s=e;const r=async()=>{try{const t=await(await y(!0)).createWritable();await t.write(JSON.stringify(e,null,2)),await t.close()}catch(o){console.log("Failed to write booklist.json",o)}};return f=f.then(r,r),f}async function p(e,r){const o=await l(),t=o.findIndex(i=>i.bookId===e);let n;t>=0?(n=[...o],n[t]={...n[t],...r}):n=[r,...o],await u(n)}async function O(e){await u(e)}async function D(e,r,o){if(!a)throw new Error("Storage not configured");const t=`${e}.${o||"pdf"}`,i=await(await g(t,!0)).createWritable();return await i.write(r),await i.close(),{filename:`books/${t}`,size:r.size,savedAt:new Date().toISOString()}}async function F(e){const r=await l(),o=r.filter(t=>t.bookId!==e);o.length!==r.length&&await u(o)}export{P as a,H as b,D as c,N as d,O as e,E as f,l as g,x as h,S as i,B as s,p as u};
